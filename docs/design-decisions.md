# 설계 결정 과정

[← 메인으로 돌아가기](../README.md)

---

## 📋 목차

1. [문제 정의](#문제-정의)
2. [핵심 설계 원칙](#핵심-설계-원칙)
3. [대안 비교와 선택](#대안-비교와-선택)
4. [의사결정 프레임워크](#의사결정-프레임워크)

---

## 문제 정의

### 많은 게임 서비스가 겪는 공통 문제

```
🚨 사용자 이벤트 증가에 따른 서버 복잡도 폭증
🚨 실시간 처리와 기록 처리의 경계 불명확
🚨 장애 발생 시 영향 범위가 예측되지 않음
🚨 특정 개발자에게 운영과 구조 이해가 집중됨
🚨 기능 추가 시 기존 로직의 안정성이 지속적으로 훼손됨
```

### 핵심 판단

> **문제의 핵심은 기술 부족이 아니라 구조 부재라고 판단했습니다.**

---

## 핵심 설계 원칙

### 5대 원칙

```
1. 실시간 판정은 반드시 메모리에서 즉시 확정한다
2. 기록과 확장은 이벤트로 분리한다
3. 장애는 전파되지 않고 국소화되어야 한다
4. 기능 추가가 기존 흐름을 깨지 않아야 한다
5. 운영자가 시스템을 "이해할 수 있어야" 한다
```

### 의도적으로 선택하지 않은 것들

```
✗ 모든 처리를 실시간으로 만들지 않음
✗ 초기부터 마이크로서비스 구조를 사용하지 않음
✗ 게임 서버에서 DB 트랜잭션에 의존하지 않음
```

**이 선택들은 단순한 기술 취향이 아니라, 운영 복잡도와 실패 비용을 고려한 판단의 결과입니다.**

---

## 대안 비교와 선택

### 고려했지만 선택하지 않은 대안들

#### 대안 1: 게임 서버 직접 DB 접근

```
[ Game Server ] → [ Database ]
    ↓ 동기 CRUD
[ Response ]
```

**선택하지 않은 이유**:

```
❌ GameLoop Tick이 DB 응답을 기다림
❌ DB 장애 시 게임플레이 중단
❌ DB 부하가 곧 게임 서버 부하
❌ 트랜잭션 실패 시 복구 복잡
```

**트레이드오프 분석**:

| 항목 | 직접 DB 접근 | 이벤트 기반 |
|------|-------------|-------------|
| 구현 복잡도 | ⭐⭐ (낮음) | ⭐⭐⭐⭐ (높음) |
| 실시간 안정성 | ⭐⭐ (낮음) | ⭐⭐⭐⭐⭐ (높음) |
| 장애 격리 | ⭐ (매우 낮음) | ⭐⭐⭐⭐⭐ (높음) |
| 데이터 일관성 | ⭐⭐⭐⭐⭐ (높음) | ⭐⭐⭐ (중간) |

**결론**: 실시간 안정성과 장애 격리를 선택

---

#### 대안 2: 모든 요청 동기 처리

```
Client → Server → Process → DB → Response → Client
(모든 단계가 동기적으로 완료될 때까지 대기)
```

**선택하지 않은 이유**:

```
❌ 사용자 증가 시 선형적으로 느려짐
❌ 특정 요청이 느리면 전체 시스템 지연
❌ 장애 전파 불가피
❌ 확장 비용 급증
```

**실제 시나리오**:

```
100명 접속 시:
- 평균 응답 시간: 50ms
- 허용 가능

1000명 접속 시:
- 평균 응답 시간: 500ms
- 체감 지연 발생

10000명 접속 시:
- 평균 응답 시간: 5000ms
- 게임 불가능
```

**이벤트 기반 구조**:

```
판정은 즉시 (50ms 고정)
기록은 나중에 (비동기)
→ 사용자 수와 무관하게 안정적
```

---

#### 대안 3: 마이크로서비스 (MSA)

```
[ API Gateway ]
    ↓
[ Auth Service ] [ User Service ] [ Match Service ]
[ Inventory Service ] [ Payment Service ] ...
```

**선택하지 않은 이유**:

```
❌ 초기 복잡도 과다 (Over-engineering)
❌ 서비스 간 통신 오버헤드
❌ 분산 트랜잭션 복잡도
❌ 운영 부담 (서비스 수 × N)
❌ 개발자 인지 부하 증가
```

**언제 MSA가 필요한가?**

```
조직이 크고:
- 팀이 10개 이상
- 독립 배포 필요

기능이 명확히 분리되고:
- 도메인 경계가 확실
- 변경 주기가 다름

운영 역량이 충분할 때:
- DevOps 팀 존재
- 모니터링 인프라 구축
```

**현재 선택**: Modular Monolith

```
[ Game Server ] (Monolith)
    ├── Network Module
    ├── Domain Module
    └── Event Module

[ Platform Server ] (Monolith)
    ├── Kafka Consumer
    ├── API Module
    └── Persistence Module
```

**장점**:
- 단순한 배포
- 낮은 운영 복잡도
- 필요 시 쉽게 분리 가능

---

#### 대안 4: NoSQL Only (MongoDB/Redis만 사용)

**선택하지 않은 이유**:

```
❌ 정형 데이터 처리 어려움 (계정, 거래)
❌ 트랜잭션 제약
❌ 복잡한 쿼리 성능
❌ 운영 데이터 분석 불편
```

**선택한 구조**: Polyglot Persistence

```
Redis: 캐시 + 스냅샷
MongoDB: 비정형 데이터 + 스냅샷
MySQL: 정형 데이터 + 트랜잭션
```

**각자의 강점을 활용**

---

#### 대안 5: UDP 프로토콜

**선택하지 않은 이유**:

```
✓ UDP가 더 빠름 (사실)
✓ 패킷 손실 허용 가능 (사실)

그러나:
❌ 구현 복잡도 증가
❌ 포트폴리오 목적상 TCP로 충분
❌ 서버 권한 모델 증명에 UDP 불필요
```

**실무 판단**:
- FPS, 레이싱: UDP 필요
- 턴제, 퍼즐, MOBA: TCP 충분
- 포트폴리오: **아키텍처 증명이 목표**

---

## 의사결정 프레임워크

### 선택의 기준

이 모든 선택은 다음 기준으로 판단했습니다:

```
1. 복잡도 vs 얻는 가치
2. 초기 비용 vs 확장 비용
3. 운영 난이도
4. 장애 격리 가능성
5. 팀 크기와 역량
```

### 기술 도입 의사결정 체크리스트

```
새로운 기술/패턴을 도입할 때:

질문 1: 이것 없이는 목표 달성이 불가능한가?
→ No면 도입하지 않음

질문 2: 운영 복잡도 증가를 감당할 수 있는가?
→ No면 도입하지 않음

질문 3: 팀이 이해하고 유지보수 가능한가?
→ No면 도입하지 않음

질문 4: 나중에 추가해도 늦지 않은가?
→ Yes면 지금 도입하지 않음
```

### 원칙

> **"지금 필요하지 않으면, 지금 만들지 않는다."**

---

## 주요 설계 결정 요약

### 1. 실시간 vs 비동기 분리

**결정**: 판정은 메모리, 기록은 이벤트

**이유**:
- 게임플레이 안정성 최우선
- 장애 격리 필수
- 확장 용이성

---

### 2. Server-authoritative

**결정**: 서버만 상태 변경 권한 보유

**이유**:
- 치트 방지는 구조로 해결
- 클라이언트 신뢰 불가
- 복잡도 증가는 감수

---

### 3. Event-driven Architecture

**결정**: Kafka 기반 이벤트 스트림

**이유**:
- 기능 추가 시 기존 코드 무수정
- 서비스 간 결합도 최소화
- 신규 Consumer 추가만으로 확장

---

### 4. Modular Monolith

**결정**: MSA 대신 모듈형 모노리스

**이유**:
- 초기 복잡도 최소화
- 운영 부담 감소
- 필요 시 분리 가능

---

### 5. Polyglot Persistence

**결정**: Redis + MongoDB + MySQL 혼용

**이유**:
- 각 저장소의 강점 활용
- 용도별 최적화
- 단일 DB의 한계 극복

---

## 배운 교훈

### 기술적 교훈

1. **복잡도는 비용이다**
   - 복잡한 구조는 반드시 그만한 가치를 제공해야 함
   - "할 수 있다"와 "해야 한다"는 다름

2. **장애는 언제나 발생한다**
   - 장애를 막는 것보다 격리하는 것이 현실적
   - "장애 시 어떻게 되는가"가 설계의 핵심

3. **확장은 선형적이어야 한다**
   - 사용자 2배 → 비용 2배가 이상적
   - 비선형 확장은 지속 불가능

### 조직 관점 교훈

1. **문서화는 필수다**
   - 개인의 지식은 조직에 남지 않음
   - 구조를 설명할 수 없으면 좋은 구조가 아님

2. **운영 가능성이 구현보다 중요하다**
   - 만들 수 있어도 운영할 수 없으면 의미 없음
   - 운영팀이 이해할 수 있는 구조여야 함

3. **인수인계 가능한 시스템**
   - 특정 개발자에게 의존하는 구조는 위험
   - 시스템 자체가 설명할 수 있어야 함

---

## 다음 단계에서의 결정

### Phase 2: 이벤트 신뢰성

**결정 예정**:
- DLQ 전략
- Retry 정책
- Idempotency 구현 방식

### Phase 3: Snapshot

**결정 예정**:
- 스냅샷 주기
- Checksum 알고리즘
- 복구 우선순위

---

[← 메인으로 돌아가기](../README.md)